# Template AnyContainer

## Motivation

In C++ 17 there are new library components `any`, `variant` and `optional` that have existed in the boost libraries for a while.  They have related functionality.  Since `any` can emulate the functionality of `variant` and `optional` this document explains their functionality from the perspective of `any` and will serve the basis for discussions of `variant` and `optional`.

`any` allows holding a value of *any* type, hence the name.  It also allows holding no value.  It is conceptually similar to the concept of value or object in JavaScript.  `any` allows the applicaton of type-less programming techniques.

There are use cases in which strong typing make things harder.  For example, a processor of a non-trivial language to specify configurations; when the processor attempts to parse a particular configuration in that language, it does not know exactly what is the kind of objects that it will be generating.  In the C family of languages relaxation of type strictness is typically achieved through the use of referential semantics (that is, dealing with the values through their addresses as opposed to they themselves) and using `void *`, the generic pointer type.  In languages such as Java, this is typically achieved through the "objectification" of values (converting values such as an `int`, which is a primitive type, into an `Integer`, an object) and using references to a common base class.  In Java all objects inherit from the universal object type, `Object`, and frequently Java programmers use `Object` for this very reason, for example the library of containers.  Also, in Java, as well as other strongly object oriented languages, including C++, this type strictness relaxation encourages class hierarchies and the use of references (or pointers) to base classes.  My experience working with JavaScript allowed me to understand that the superimposition of arbitrary taxonomies to relax type strictness is pure busy work.  On the other hand, using referential semantics plus `void *` leads to just as underperforming code but also ardous and error prone.

Therefore there is desirability for getting rid of the strictness of types while at the same time preserving the advantges of type strictness, especially the object lifetime guarantees, the **RAII** idiom.

`any` is a container of objects of arbitrary type capable of managing their lifetimes and to which RAII fully applies.

## Type Erasure

The technique for type strictness relaxation is called **type erasure**.  ["Type Erasure"](https://en.wikipedia.org/wiki/Type_erasure) refers to whenever the type of an entity ceases to be compilation-time information and becomes runtime information.  Hence it implies a run time penalty.  Type erasure can be accomplished in many different ways, all revolving around the concept of **type switching**, any of the mechanisms for discovering the type of an object at runtime.  In C++ type switching is very well supported through the same features that support run time polymorphism, the "virtual" methods, overrides and the virtual function pointer table, the "**vtable**".  The vtable is, to my knowledge, universally implemented as that objects begin with the vtable pointer, a hidden member value.  The vtable is the type switch: type-specific features are accessible as indices into the vtable.  Another popular type switching mechanism, applicable to C and C++ is to use a type-switch field and have explicit switching, typically with a switch itself: `switch(object.typeId) { case TYPE1: ... }`.  One advantage that sometimes justifies all the extra programming effort for this kind of type switching is that the type switch can be as small as one bit.  Also, some commonality between the types can be achieved in cascading if-then-elses on the type id field.

Curiously, both GCC libstdc++ and Clang's libc++ implement the type erasure needed in `any` by instantiating a template function which "knows" what is the type of the held object and internally has a switch with the many tasks required to manage the held object.  Careful inspection shows this does not perform any better than the choice I used, typical C++ runtime polymorphism based on overrides of virtual methods, but in my subjective opinion, leads to error-prone code.

